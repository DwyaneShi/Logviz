#!/usr/bin/env python
'''
:mod:`module.ecb`
'''

import re
import math
from mpl_toolkits.mplot3d import axes3d
from matplotlib import cm
from scipy.interpolate import griddata
import matplotlib.patches as mpatches
import matplotlib.pyplot as plt

import numpy as np

from module import AbstractModule
from util import SizeUtils
from util import NumberUtils

class ECB(AbstractModule):
    '''
    ECB
    '''
    """Regexp pattern for logs generated by RawErasureCoderBenchmark."""
    PATTERN_ECB = r"Using (?P<buffer_size>\S+) buffer\.\n(?:.*?\n)*?(?P<coder>.*?) coder (?P<method>\S+?)\s(?P<total_data_size>\S+) data, with chunk size (?P<chunk_size>.*?)\nTotal time: (?P<total_time>.*?)\ss\.\nTotal throughput: (?P<total_throughput>.*?) MB/s\nThreads statistics:\s*(?P<threads_num>.*?) threads in total\.\nMin: (?P<time_min>.*?) s, Max: (?P<time_max>.*?) s, Avg: (?P<time_avg>.*?) s, 90th Percentile: (?P<time_90>.*?) s\."

    """Regexp terms for finding fields in ECB logs"""
    FIELDS_ECB = [
        'buffer_size', 'coder', 'method', 'total_data_size', 'chunk_size', 'total_time',
        'total_throughput', 'threads_num', 'time_min', 'time_max', 'time_avg', 'time_90'
    ]

    TYPES_ECB = [
        "TotalThroughput", "Throughput", "Latency"
    ]

    def __init__(self, sub_type):
        if sub_type not in self.TYPES_ECB:
            raise Exception("{} is not one of {}".format(sub_type, self.TYPES_ECB))
        self.sub_type = sub_type

    def delimeter(self):
        return "**********"
    def pattern(self):
        return re.compile(self.PATTERN_ECB)
    def split_info(self, parts):
        fields = self.FIELDS_ECB
        results = []

        for part in parts:
            result = {}
            for sectionname in fields:
                value = part[sectionname]
                if sectionname == 'buffer_size':
                    value = SizeUtils.convert_size(value)
                if sectionname == 'chunk_size':
                    value = SizeUtils.convert_size(value)
                if sectionname == 'total_data_size':
                    value = SizeUtils.convert_size(value)
                value = NumberUtils.as_number_otherwise_string(value)
                result[sectionname] = value
            results.append(result)
        return results
    def num_plots(self):
        return 1
    def xy_data(self, data):
        xdata = set()
        ydata = set()
        for cell in data:
            xdata.add(cell['chunk_size'])
            ydata.add(cell['threads_num'])
        self.xdata = sorted(xdata)
        self.ydata = sorted(ydata)
    def preprocess_data(self, data):
        results = {}
        for cell in data:
            coder = cell["coder"].replace("Java", "").strip()
            if coder == "Mellanox":
                coder = "Mellanox EC Offload"
            elif coder == "ISA-L":
                coder = "Intel ISA-L"

            method = cell["method"]
            chunk_size = cell["chunk_size"]
            buffer_size = cell["buffer_size"]
            threads_num = cell["threads_num"]
            factor = buffer_size * threads_num
            iteration = cell["total_data_size"] / factor

            if self.sub_type == "TotalThroughput":
                result = cell["total_throughput"]
            elif self.sub_type == "Throughput":
                result = cell["total_throughput"] / threads_num
            else:
                result = cell["time_avg"]

            if method not in results:
                results[method] = {}
            if iteration not in results[method]:
                results[method][iteration] = {}
            if chunk_size not in results[method][iteration]:
                results[method][iteration][chunk_size] = {}
            if threads_num in results[method][iteration][chunk_size] \
                    and results[method][iteration][chunk_size][threads_num]:
                results[method][iteration][chunk_size][threads_num].append(result)
            else:
                results[method][iteration][chunk_size][threads_num] = [result]

        for method in results:
            for iteration in results[method]:
                for chunk_size in results[method][iteration]:
                    for threads_num in results[method][iteration][chunk_size]:
                        results[method][iteration][chunk_size][threads_num] = \
                            np.mean(results[method][iteration][chunk_size][threads_num])
        self.coder = coder
        self.results = results

    def generate_ticks(self):
        xcount = len(self.xdata)
        xtick_label_stepsize = xcount / 15
        if xtick_label_stepsize == 0:
            xtick_label_stepsize = 1
        self.xticks = np.arange(0, xcount, xtick_label_stepsize)
        self.xtick_labels = [SizeUtils.number_to_size(self.xdata[i]) for i in self.xticks]

        ycount = len(self.ydata)
        ytick_label_stepsize = ycount / 15
        if ytick_label_stepsize == 0:
            ytick_label_stepsize = 1
        self.yticks = np.arange(0, ycount, ytick_label_stepsize)
        self.ytick_labels = [self.ydata[i] for i in self.yticks]

    def paint(self, fig):
        x_labels = 14
        y_labels = 7
        method = "encode"
        blocks = 1024

        ax = fig.gca(projection='3d')
        results = self.results[method][blocks]
        xticks, yticks = np.meshgrid(self.xticks, self.yticks)
        xdata, ydata = np.meshgrid(self.xdata, self.ydata)

        if self.sub_type != "Latency":
            unit, zticks = self.__throughput_array(results, xdata, ydata)
        else:
            unit = "sec"
            zticks = np.array([results[x][y] for x, y in zip(np.ravel(xdata), np.ravel(ydata))])

        zticks = zticks.reshape(xdata.shape)
        ax.plot_surface(xticks, yticks, zticks, alpha=0.6)
        xtick_labels = [self.xtick_labels[int(x)] for x in ax.get_xticks() if int(x) in range(len(self.xtick_labels))]
        ytick_labels = [self.ytick_labels[int(y)] for y in ax.get_yticks() if int(y) in range(len(self.ytick_labels))]
        x_plane = ax.contour(xticks, yticks, zticks, zdir='x', offset=0 - 0.230, cmap=cm.Dark2)
        y_plane = ax.contour(xticks, yticks, zticks, zdir='y', offset=y_labels - 1 + 0.130, cmap=cm.cool)
        x_legends = ["chunk size: {}".format(x) for x in xtick_labels]
        y_legends = ["#threads: {}".format(y) for y in ytick_labels]

        for i in range(len(xtick_labels)):
            if (i % 2) == 1:
                xtick_labels[i] = ""
        for i in range(len(ytick_labels)):
            if (i % 2) == 1:
                ytick_labels[i] = ""
        if self.sub_type == "TotalThroughput":
            title = "Total Throughput"
        else:
            title = self.sub_type

        ax.set_zlabel('{} ({})'.format(title, unit))
        plt.title('{} - {}'.format(title, self.coder))
        ax.set_xlabel('Chunk Size')
        ax.set_ylabel('#Threads')
        ax.set_xlim(0, x_labels - 1)
        ax.set_ylim(0, y_labels - 1)
        ax.set_zlim(0)
        ax.set_xticklabels(xtick_labels)
        ax.set_yticklabels(ytick_labels)

        x_num = len(x_plane.collections)
        y_num = len(y_plane.collections)
        lg = plt.legend(x_plane.collections + y_plane.collections,
                        x_legends[(len(x_legends) - x_num):] + y_legends[(len(y_legends) - y_num):],
                        ncol = int(math.ceil(x_num + y_num) / 4), bbox_to_anchor=(0.95, 0), frameon=False)
        if lg is not None:
            lg.get_frame().set_alpha(0)
            lg_txts = lg.get_texts()
            plt.setp(lg_txts, fontsize=6)
        box = ax.get_position()
        ax.set_position([box.x0 - box.width * 0.1, box.y0 + box.height * 0.14, box.width, box.height])

    def __throughput_array(self, source, xdata, ydata):
        temp_array = [source[x][y] for x, y in zip(np.ravel(xdata), np.ravel(ydata))]
        unit = "MB/sec"
        if np.mean(temp_array) > 5 * 1024:
            temp_array = [x / 1024 for x in temp_array]
            unit = "GB/sec"
        return (unit, np.array(temp_array))
